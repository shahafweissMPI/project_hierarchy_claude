# -*- coding: utf-8 -*-
"""
Created on 2025-07
Author: Dylan Festa

Run it locally with:
panel serve --address 0.0.0.0 --allow-websocket-origin='*' --disable-index   --port 8081 --dev app.py 

Then share it with the world using tailscale:
sudo tailscale funnel --set-path /rasters01 --bg 8081

They you can access it at the tailscale URL, adding /app at the end, e.g.:
https://d-02104.tail7bf618.ts.net/test01/app

"""
import threading, numpy as np, holoviews as hv, datashader as ds, panel as pn
import holoviews.operation.datashader as hd
#from bokeh.models import ColumnDataSource
hv.extension("bokeh")
pn.extension(loading_spinner="dots")  # nicer default spinner

# ------------------------------------------------------------------
# Your domain‑specific utilities (unchanged)
# ------------------------------------------------------------------


import pandas as pd
import os
import h5py

import read_data_light as rdl
import preprocess as pre
from preprocess import SpikeTrains

read_date = "20250730"  # date of the local file to read


def filter_good_paths_from_local(df_paths):
    local_file_path = f'/tmp/all_rasters_{read_date}.hdf5'
    hfile = h5py.File(local_file_path, 'r')
    idx_delete = []
    for k,r in df_paths.iterrows():
        mouse, session = r.Mouse_ID, r.session
        group_name = f"{mouse}/{session}"
        if group_name not in hfile:
            print(f"Warning: Group {group_name} not found in local file.")
            idx_delete.append(k)
        
    hfile.close()
    if idx_delete:
        print(f"Deleting {len(idx_delete)} rows from good paths DataFrame.")
        df_paths = df_paths.drop(index=idx_delete)
    else:
        print("All groups found in local file, no rows deleted.")
    return df_paths



def read_spiketrains_from_local(mouse_session):
    """Read spiketrains from local files instead of the server.
    The local file is generated by 'save_all_rasters_locally.py'.
    """
    local_file_path = f'/tmp/all_rasters_{read_date}.hdf5'
    # check if exists
    if not os.path.exists(local_file_path):
        raise FileNotFoundError(f"Local file {local_file_path} not found.")
    hfile = h5py.File(local_file_path, 'r')
    i  = idx_of[mouse_session]
    _row  = good_paths_df.iloc[i]
    mouse,session = _row.Mouse_ID, _row.session
    group_name = f"{mouse}/{session}"
    if group_name not in hfile:
        raise KeyError(f"Group {group_name} not found in local file.")
    group = hfile[group_name]
    units = group['units'][:]
    unit_locations = group['unit_locations'][:]
    # convert unit locations from bytes to strings
    unit_locations = [loc.decode('utf-8') for loc in unit_locations]
    n_units = len(units)
    # now extract all spike trains
    trains = []
    for i in range(n_units):
        if str(i) in group:
            train = group[str(i)][:]
            trains.append(train)
        else:
            print(f"Warning: Spike train {i} not found in group {group_name}.")
    hfile.close()
    # Create a SpikeTrains object
    spiketrains_obj = SpikeTrains.from_spike_list(trains,
                                                   t_start=0.0,
                                                   t_stop=max([spk[-1] for spk in trains]) + 0.00001,
                                                   units=units,
                                                   unit_location=unit_locations)

    return spiketrains_obj

def make_raster_plot(mouse_session, width=1000, height=800):
    print(f"Generating raster plot for {mouse_session}")
    st  = read_spiketrains_from_local(mouse_session)
    seg = st.get_line_segments()
    seg = [(*p1,*p2) for p1,p2 in zip(seg[::2], seg[1::2])]
    # dataframe with four columns: x0, y0, x1, y1
    seg_df = pd.DataFrame(seg, columns=["x0", "y0", "x1", "y1"])
    _hover_tooltips = [("neuron idx", "@y{0}"),
                      ("time (s)", "@x{0}")]
    hv_seg = hv.Segments(seg_df)
    hv_seg.opts(color="black", line_width=1,
                    width=width, height=height)
    hv_seg.opts(tools=["hover"],hover_tooltips=_hover_tooltips)
    _the_plot = hd.rasterize(hv_seg)
    _the_plot.opts(cmap=["black"], width=width, height=height)
    # x label
    _the_plot.opts(xlabel="Time (s)", ylabel="Neuron index",
                   title=f"Raster plot for {mouse_session}")
    _the_plot.opts(tools=["hover"], hover_tooltips=_hover_tooltips)
    print(f"Raster plot for {mouse_session} generated.")
    return _the_plot


# ------------------------------------------------------------------
# Load and filter good paths
# ------------------------------------------------------------------

good_paths_df = filter_good_paths_from_local(rdl.get_good_paths())



mouse_session_list = [f"{r.Mouse_ID} / {r.session}" for _, r in good_paths_df.iterrows()]
idx_of            = dict(zip(mouse_session_list, range(len(mouse_session_list))))


plot_width = 1600
plot_height = 800

# ------------------------------------------------------------------
# Reactive UI
# ------------------------------------------------------------------
select     = pn.widgets.Select(name="Select mouse/session",
                               options=mouse_session_list, width=300)
select.value = mouse_session_list[11]  # default selection
refresh_btn = pn.widgets.Button(name="Refresh plot", button_type="primary")

header   = pn.pane.Markdown("", stylesheets=[":host{font-size:12px;font-weight:bold}"])
plot_pane = pn.pane.Placeholder("⏳ LOADING …", width=plot_width, height=plot_height)  # shows text *and* spinner
plot_pane.loading = True                                                # overlay spinner immediately

def _update_plot(*events):
    """Start a background thread that builds the plot, then swap it in."""
    sess = select.value
    header.object  = f"Now plotting mouse/session : **{sess}** …"
    plot_pane.object, plot_pane.loading = "⏳ LOADING …", True           # fast UI feedback

    def work():
        new_plot = make_raster_plot(sess)
        def finalize():
            plot_pane.object, plot_pane.loading = new_plot, False
            header.object = f"Plot for mouse/session **{sess}** : "
        pn.state.execute(finalize)     # back on main thread ✔︎
    threading.Thread(target=work, daemon=True).start()

# trigger on selector change **and** on explicit button press
select.param.watch(_update_plot, "value")
refresh_btn.on_click(_update_plot)

# kick‑off first render
_update_plot()

pn.Column(pn.Row(select, refresh_btn), header, plot_pane).servable()